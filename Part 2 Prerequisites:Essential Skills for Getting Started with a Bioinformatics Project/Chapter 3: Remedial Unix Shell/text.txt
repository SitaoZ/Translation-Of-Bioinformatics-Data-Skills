第三章 辅导Unix shell
    unixshell是生物信息学的基础计算环境。shell作为我们与大型生物信息学程序的接口，作为检查数据和
中间结果的交互式控制台，以及作为我们的管道和工作流的基础设施。本章将帮助您熟练掌握在本书的其余部分中
被广泛使用的必要的unixshell概念。这将使您能够在以后的章节中关注命令的内容，而不是专注于理解shell语法。
    本书假设您熟悉基本主题，例如终端是什么，shell是什么，Unix文件系统层次结构，目录移动，文件权限，
执行命令并使用文本编辑器。如果这些话题对你来说很陌生，那么最好温习一下使用更基本的材料（请参阅第16页
的“本书的假设”以获取一些资源）。在本章中，我们将讨论在生物信息学中如何使用shell的深层基础的补救性概念：
流、重定向、管道、运行程序的工作以及命令替换。了解这些shell主题将使您能够使用shell处理数据（第7章）和
构建管道和工作流（第12章）。在本章中，我们还将了解unixshell在我们如何进行现代生物信息学方面有着如此突
出的作用。如果你觉得已经熟悉了这些shell主题，我建议阅读本文的第一部分然后跳到第四章。
    为什么我们在生物信息学中使用Unix？模块化和Unix哲学
    想象不用Unix作为生物信息学学的环境，我们将完成我们整个项目使用单个大的程序。我们通常不会认为生物
信息项目是一个大的程序，但是我们可以写一个复杂的程序将原始数据作为输入，在一个小时的数据处理之后，输出
可发表的图片和结果的最终表格。对于一个变异calling项目来说，这个程序通常包括原始数据读取，序列比对，
变异calling，变异过滤，最后结果分析。这个程序编码通常很大，可能会有几千行。
    虽然像这样的程序可以根据特定的变量调用项目进行定制，但它的通用性不足以适应其他程序。考虑到它庞大的
代码量，这个程序对于每个新项目的调整是不切实际的。庞大的代码库也会使查找和修复bug变得困难。更糟糕的是，
除非我们的单片程序被显式地编程为检查步骤之间的数据看起来没有错误，否则一个步骤可能会出错（我们不知道），
它会尽职尽责地用不正确的数据继续分析。虽然这个自定义程序在计算上可能更高效，但这将以脆弱、难以修改、容
易出错（因为它使检查中间数据变得非常困难）为代价，并且不适用于未来的项目。Unix是生物信息学的基础计算环
境，因为它的设计理念与这种僵硬和脆弱的方法是对立的。unixshell被设计成允许用户通过将较小的模块化程序连
接在一起来轻松地构建复杂的程序。这种方法是Unix的理念：
    这就是Unix的哲学：编写只做一件事而且做得很好的程序。编写程序一起工作。编写处理文本流的程序，因为这
是一个通用接口。unixshell为这些程序提供了一种相互通信（管道）以及写入和读取文件（重定向）的方法。Unix
的核心程序（我们将在第7章的命令行中使用这些程序来分析数据）是模块化的，设计用于与其他程序很好地协同工作。
Unix哲学的模块化方法在生物信息学中有许多优势：
    使用模块化工作流，可以更容易地发现错误并找出错误发生的位置。在模块化工作流中，每个组件都是独立的，这
使得更容易检查中间结果的不一致性并隔离问题台阶。相比之下，大型非模块程序隐藏了潜在的问题（所有你看到的是它
的最终输出数据），这使得隔离问题的源头变得困难。
    模块化工作流程允许我们尝试其他方法和方法，因为单独的组件可以很容易地与其他组件交换。例如，如果您怀疑某
个特定的比对软件在你的数据变现不好，很容易把这个软件换成另一个。采用模块化工作流程，这是很容易的，我们的比对
与下游分析步骤分开比如变异获取或RNAseq分析。
    我们可以选择适当的模块化语言和工具对于特定任务。这是Unix环境适合生物信息学的另一个原因嗯：它允许我们结
合命令行工具进行交互探索数据（在第7章中有更深入的介绍），Python用于更复杂的脚本，统计分析用R。当程序设计用于
在其他程序中，为特定任务选择专用工具是没有成本的-在生物信息学中我们经常做一些事情。
    模块化程序是可重用的，适用于许多类型的数据。写得好模块化程序可以重新组合并应用于不同的问题和数据集，因为
它们是独立的部分。最重要的是，通过重新组合模块组件，新问题可以用现有工具解决。
    除了强调程序模块化和接口外，McIlroy引用还提到了文本流。我们将在本章中讨论Unix流，但是在我们如何处理大数
据时，流概念非常重要。对大数据的定义可能会有所不同，虽然对一个刚开始测序的实验室来说，单一lane的测序数据可能会
很大，但与较大的测序中心每小时处理的数据相比，这是微不足道的。不管怎样，排序数据的通道太大了，不适合大多数标准
台式机的内存。如果我需要搜索确切的字符串“gtgatataactgcgaa”我不能在记事本里打开数据.Find feature可以精确定
位它在哪里发生，但是内存不够记住所有这些核苷酸。相反，工具必须依赖于数据流，从源中读取并被快速处理。
通用Unix工具和许多生物信息学程序都被设计成通过一个流接收输入并通过另一个流传递输出。正是这些文本流允许我们两个
程序耦合集成到工作流和处理数据中，而无需在计算机内存中存储大量数据。
    不同版本的shell
    纵观整本书，我们使用的是Unix shell,而不是其他版本的shell.shell是计算机程序，而且许多程序的设计和完成
都是在特定的shell版本下进行的。这些不同的版本可能对新用户产生困难，因为不同的版本相比有一些差异。
    为了解决这个问题，确保你使用的是Bourne-again shell或者也叫bash.Bash应用广泛，是苹果和乌班图等操作系统
默认的shell。你可以使用 echo $SHELL 来确认你使用的是哪一种shell。虽然最好也检查一下echo$0的内容，因为即使你
识别你的外壳不同于外壳！）.我不建议使用其他的shell,例如Cshl,他的后代tcsh或者ksh，因为这些在生物信息中不常见，
可能和本书中的示例不兼容。bourneshell（sh）是Bourne again shell（bash）的前身；但是bash是较新的，而且通
常是首选的。
    可以使用chsh命令更改shell。在我的生物信息学的项目中，我通常使用的是Zshell作为我的默认shell。Zshell有很多
实用的特性（例如更好的自动化），使用起来更加方便。除非另有明确说明，否则本书中的所有内容都与这两个shell兼容。
如果您对一般的shell基础知识很有信心，那么可以尝试zshell。我已经在本章GitHub的自述文件中包含了关于zshell的资源。
    关于unixshell的最后一点要强调的是，它的功能非常强大。有了通配符之类的简单功能，将一个命令应用于数百个文件是
很简单的。但是这种能力带来了风险：unixshell不关心命令是否输入错误或如果他们要销毁文件；unixshell并不是为了阻止你
这样做不安全的东西。Gary bernhardt给出了一个很好的类比：Unix就像一个电锯。电锯是一种功能强大的工具，使许多困难的
工作，如切割厚圆木相当容易。不幸的是，这种力量伴随着危险：电锯可以很容易地切断你的腿（嗯，技术上更容易）。例如，考虑
```bash 
$ rm -rf tmp-data/aligned-reads* # deletes all old large files
$ # versus
$ rm -rf tmp-data/aligned-reads * # deletes your entire current directory
rm: tmp-data/aligned-reads: No such file or directory
```
    在Unix中，一个空格可能意味着清理一些旧文件和延迟完成项目之间的区别，因为您意外地删除了所有内容。
这不是什么应该引起警报的东西，这是使用强大工具的结果。相反，在实验或尝试时要采取谨慎的态度新命令
（例如，在一个临时目录中工作，如果不确定命令的行为方式，则使用假文件或数据，并始终保留备份）。
Unix shell具有允许您执行功能强大（可能不安全）的功能，这是其设计的一个重要部分：
    Unix并不是为了阻止用户做蠢事，因为这也会阻止他们做聪明的事。---Doug Gwyn
    以巧妙的方式处理重复的大型数据处理任务是成为熟练的生物信息学家。shell 通常是这些做任务的最快工具。
在本章中，我们将重点介绍这些Unix shell基本的东西，这些基本的东西允许我们从简单的部分构建复杂的程序：
流，重定向，管道，进程，命令替换。在第十二章中，我们将会学习更多的自动化任务，这个是Unixshell中很重要
的一部分。
    流和重定向
    生物信息学数据一般是文本，例如测序文件中的ATGC,参考基因组，制表符分割的基因坐标文件。文本文件通常非
常大，这就是Unix处理文本流的哲学的原因在生物信息学中很有用：文本流允许我们处理流数据而不是把它读取到内存
中。
    例如，假设我们有两个装满核苷酸序列的文件，以FASTA的格式储存，一种标准的文本格式，用于存储序列数据（通常
是DNA，但偶尔也有）蛋白质也是）。即使是将这两个大文件合并到一个文件中的简单任务也会变得很棘手，尽管这些文件的
大小只有几GB。如果不使用unixshell，如何完成这个简单的任务？您可以尝试打开一个文件，选择并复制其所有内容，
然后将其粘贴到另一个文件中。但是，这不仅需要在内存中加载两个文件，而且在选择“全部”、“复制”和“粘贴”时，还需要
使用额外的内存来复制一个文件。像这样的方法不适合我们在生物信息学中经常使用的数据量。此外，将内容粘贴到文件中并
没有遵循第1章：将数据视为只读的建议。如果出了问题，其中一个文件（或两个文件都有！）很容易被破坏。更糟糕的是，
复制和粘贴大文件会占用大量内存，因此您的计算机很可能出现问题。Streams为这些问题提供了一个可伸缩的、健壮的解决方案。
    重定向到标准输出
    简单的合并两个文件可以采用流。使用流可以让我们减少内存的使用。相反，我们合并大文件通过把他们打印到标准输出，
然后重定向流到一个文件。你可能是用cat打印文件的内容到标准输出（当没有重定向时，它会被打印到终端屏幕上）。例如，
我们可以看看tb1-蛋白质.fasta文件（可在GitHub上本章的目录中找到）使用cat将其打印到标准输出：
```bash
$ cat tb1-protein.fasta
>teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
```
    cat还允许我们将多个文件的内容按命令参数出现的顺序打印到标准输出流中。这基本上连接了这些文件，如下所示的tb1和
tga1翻译序列：
```bash 
$ cat tb1-protein.fasta tga1-protein.fasta
>teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
>teosinte-glume-architecture-1 protein
DSDCALSLLSAPANSSGIDVSRMVRPTEHVPMAQQPVVPGLQFGSASWFP
RPQASTGGSFVPSCPAAVEGEQQLNAVLGPNDSEVSMNYGGMFHVGGGSG
GGEGSSDGGT
```
    虽然这些文件已连接，但结果不会保存在这些文件的任何位置线只是打印到终端屏幕上。为了保存这些串联的
结果到一个文件，你需要从你的终端重定向这个标准输出流屏蔽到文件。重定向是Unix中的一个重要概念，也是生
物信息学中经常使用的概念。
    重定向到“标准”或“我们”操作符>输出。接线员>将标准输出重定向到文件并覆盖该文件的任何现有内容（请注
意这一点并小心），而后面的运算符>>会附加到文件中（保留内容，并添加到末尾）。如果没有现有文件，则操作员
将在将输出重定向到它之前创建它。把我们的两个FASTA连在一起文件，我们像以前一样使用cat，但将输出重定向
到一个文件：
    $ cat tb1-protein.fasta tga1-protein.fasta > zea-proteins.fasta
    请注意，当您将标准输出重定向到文件时，您的终端屏幕上不会打印任何内容。在我们的示例中，整个标准输
出流以zea-proteins.fasta文件。将标准输出流重定向到文件如下所示:
    我们可以通过检查这个目录中最近创建的文件是否是我们刚刚创建的文件（即zea）来验证我们的重定向是否
正常工作-蛋白质.fasta):
```bash
ls -lrt
total 24
-rw-r--r-- 1 vinceb staff 353 Jan 20 21:24 tb1-protein.fasta
-rw-r--r-- 1 vinceb staff 152 Jan 20 21:24 tga1-protein.fasta
-rw-r--r-- 1 vinceb staff 505 Jan 20 21:35 zea-proteins.fasta
```
    将-lrt添加到ls列出此目录中以列表格式（-l）的文件，倒序（-r）时间排序（-t）（有关详细信息，请参
阅man ls）。另外，请注意这些标志组合成-lrt；这是一个常见的语法快捷方式。如果你想看最新的文件在顶部，
您可以省略r标志。
    重定向标准错误
    由于许多程序使用标准输出流来输出数据，因此流对于用户要读取的错误、警告和消息是必需的。标准错误是
一个仅用于此目的的流（如图3-1所示）。像标准的输出，默认情况下，标准错误被定向到您的终端。在实践中，我
们经常希望将标准错误流重定向到文件以便消息、错误和警告记录到一个文件中，我们可以稍后检查。

    为了说明如何重定向标准输出和标准错误，我们将使用ls-l命令列出现存在的文件（tb1.fasta）和不存在的文件
（leafy1.fasta）。现有文件tb1.fasta的ls-l输出将被发送到标准输出，同时会出现一条错误消息leafy1.fasta
不存在。现有文件tb1.fasta的ls-l输出将被发送到标准输出，而错误消息leafy1.fasta不存在将输出到标准错误。
当您不重定向任何内容时，两个流都会输出到您的终端：
```bash 
$ ls -l tb1.fasta leafy1.fasta
ls: leafy1.fasta: No such file or directory
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:58 tb1.fasta
```
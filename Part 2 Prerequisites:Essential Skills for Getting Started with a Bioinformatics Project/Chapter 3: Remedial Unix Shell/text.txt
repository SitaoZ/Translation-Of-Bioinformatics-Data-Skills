第三章 辅导Unix shell
    unixshell是生物信息学的基础计算环境。shell作为我们与大型生物信息学程序的接口，作为检查数据和
中间结果的交互式控制台，以及作为我们的管道和工作流的基础设施。本章将帮助您熟练掌握在本书的其余部分中
被广泛使用的必要的unixshell概念。这将使您能够在以后的章节中关注命令的内容，而不是专注于理解shell语法。
    本书假设您熟悉基本主题，例如终端是什么，shell是什么，Unix文件系统层次结构，目录移动，文件权限，
执行命令并使用文本编辑器。如果这些话题对你来说很陌生，那么最好温习一下使用更基本的材料（请参阅第16页
的“本书的假设”以获取一些资源）。在本章中，我们将讨论在生物信息学中如何使用shell的深层基础的补救性概念：
流、重定向、管道、运行程序的工作以及命令替换。了解这些shell主题将使您能够使用shell处理数据（第7章）和
构建管道和工作流（第12章）。在本章中，我们还将了解unixshell在我们如何进行现代生物信息学方面有着如此突
出的作用。如果你觉得已经熟悉了这些shell主题，我建议阅读本文的第一部分然后跳到第四章。
    为什么我们在生物信息学中使用Unix？模块化和Unix哲学
    想象不用Unix作为生物信息学学的环境，我们将完成我们整个项目使用单个大的程序。我们通常不会认为生物
信息项目是一个大的程序，但是我们可以写一个复杂的程序将原始数据作为输入，在一个小时的数据处理之后，输出
可发表的图片和结果的最终表格。对于一个变异calling项目来说，这个程序通常包括原始数据读取，序列比对，
变异calling，变异过滤，最后结果分析。这个程序编码通常很大，可能会有几千行。
    虽然像这样的程序可以根据特定的变量调用项目进行定制，但它的通用性不足以适应其他程序。考虑到它庞大的
代码量，这个程序对于每个新项目的调整是不切实际的。庞大的代码库也会使查找和修复bug变得困难。更糟糕的是，
除非我们的单片程序被显式地编程为检查步骤之间的数据看起来没有错误，否则一个步骤可能会出错（我们不知道），
它会尽职尽责地用不正确的数据继续分析。虽然这个自定义程序在计算上可能更高效，但这将以脆弱、难以修改、容
易出错（因为它使检查中间数据变得非常困难）为代价，并且不适用于未来的项目。Unix是生物信息学的基础计算环
境，因为它的设计理念与这种僵硬和脆弱的方法是对立的。unixshell被设计成允许用户通过将较小的模块化程序连
接在一起来轻松地构建复杂的程序。这种方法是Unix的理念：
    这就是Unix的哲学：编写只做一件事而且做得很好的程序。编写程序一起工作。编写处理文本流的程序，因为这
是一个通用接口。unixshell为这些程序提供了一种相互通信（管道）以及写入和读取文件（重定向）的方法。Unix
的核心程序（我们将在第7章的命令行中使用这些程序来分析数据）是模块化的，设计用于与其他程序很好地协同工作。
Unix哲学的模块化方法在生物信息学中有许多优势：
    使用模块化工作流，可以更容易地发现错误并找出错误发生的位置。在模块化工作流中，每个组件都是独立的，这
使得更容易检查中间结果的不一致性并隔离问题台阶。相比之下，大型非模块程序隐藏了潜在的问题（所有你看到的是它
的最终输出数据），这使得隔离问题的源头变得困难。
    模块化工作流程允许我们尝试其他方法和方法，因为单独的组件可以很容易地与其他组件交换。例如，如果您怀疑某
个特定的比对软件在你的数据变现不好，很容易把这个软件换成另一个。采用模块化工作流程，这是很容易的，我们的比对
与下游分析步骤分开比如变异获取或RNAseq分析。
    我们可以选择适当的模块化语言和工具对于特定任务。这是Unix环境适合生物信息学的另一个原因嗯：它允许我们结
合命令行工具进行交互探索数据（在第7章中有更深入的介绍），Python用于更复杂的脚本，统计分析用R。当程序设计用于
在其他程序中，为特定任务选择专用工具是没有成本的-在生物信息学中我们经常做一些事情。
    模块化程序是可重用的，适用于许多类型的数据。写得好模块化程序可以重新组合并应用于不同的问题和数据集，因为
它们是独立的部分。最重要的是，通过重新组合模块组件，新问题可以用现有工具解决。
    除了强调程序模块化和接口外，McIlroy引用还提到了文本流。我们将在本章中讨论Unix流，但是在我们如何处理大数
据时，流概念非常重要。对大数据的定义可能会有所不同，虽然对一个刚开始测序的实验室来说，单一lane的测序数据可能会
很大，但与较大的测序中心每小时处理的数据相比，这是微不足道的。不管怎样，排序数据的通道太大了，不适合大多数标准
台式机的内存。如果我需要搜索确切的字符串“gtgatataactgcgaa”我不能在记事本里打开数据.Find feature可以精确定
位它在哪里发生，但是内存不够记住所有这些核苷酸。相反，工具必须依赖于数据流，从源中读取并被快速处理。
通用Unix工具和许多生物信息学程序都被设计成通过一个流接收输入并通过另一个流传递输出。正是这些文本流允许我们两个
程序耦合集成到工作流和处理数据中，而无需在计算机内存中存储大量数据。
    不同版本的shell
    纵观整本书，我们使用的是Unix shell,而不是其他版本的shell.shell是计算机程序，而且许多程序的设计和完成
都是在特定的shell版本下进行的。这些不同的版本可能对新用户产生困难，因为不同的版本相比有一些差异。
    为了解决这个问题，确保你使用的是Bourne-again shell或者也叫bash.Bash应用广泛，是苹果和乌班图等操作系统
默认的shell。你可以使用 echo $SHELL 来确认你使用的是哪一种shell。虽然最好也检查一下echo$0的内容，因为即使你
识别你的外壳不同于外壳！）.我不建议使用其他的shell,例如Cshl,他的后代tcsh或者ksh，因为这些在生物信息中不常见，
可能和本书中的示例不兼容。bourneshell（sh）是Bourne again shell（bash）的前身；但是bash是较新的，而且通
常是首选的。
    可以使用chsh命令更改shell。在我的生物信息学的项目中，我通常使用的是Zshell作为我的默认shell。Zshell有很多
实用的特性（例如更好的自动化），使用起来更加方便。除非另有明确说明，否则本书中的所有内容都与这两个shell兼容。
如果您对一般的shell基础知识很有信心，那么可以尝试zshell。我已经在本章GitHub的自述文件中包含了关于zshell的资源。
    关于unixshell的最后一点要强调的是，它的功能非常强大。有了通配符之类的简单功能，将一个命令应用于数百个文件是
很简单的。但是这种能力带来了风险：unixshell不关心命令是否输入错误或如果他们要销毁文件；unixshell并不是为了阻止你
这样做不安全的东西。Gary bernhardt给出了一个很好的类比：Unix就像一个电锯。电锯是一种功能强大的工具，使许多困难的
工作，如切割厚圆木相当容易。不幸的是，这种力量伴随着危险：电锯可以很容易地切断你的腿（嗯，技术上更容易）。例如，考虑
```bash 
$ rm -rf tmp-data/aligned-reads* # deletes all old large files
$ # versus
$ rm -rf tmp-data/aligned-reads * # deletes your entire current directory
rm: tmp-data/aligned-reads: No such file or directory
```
    在Unix中，一个空格可能意味着清理一些旧文件和延迟完成项目之间的区别，因为您意外地删除了所有内容。
这不是什么应该引起警报的东西，这是使用强大工具的结果。相反，在实验或尝试时要采取谨慎的态度新命令
（例如，在一个临时目录中工作，如果不确定命令的行为方式，则使用假文件或数据，并始终保留备份）。
Unix shell具有允许您执行功能强大（可能不安全）的功能，这是其设计的一个重要部分：
    Unix并不是为了阻止用户做蠢事，因为这也会阻止他们做聪明的事。---Doug Gwyn
    以巧妙的方式处理重复的大型数据处理任务是成为熟练的生物信息学家。shell 通常是这些做任务的最快工具。
在本章中，我们将重点介绍这些Unix shell基本的东西，这些基本的东西允许我们从简单的部分构建复杂的程序：
流，重定向，管道，进程，命令替换。在第十二章中，我们将会学习更多的自动化任务，这个是Unixshell中很重要
的一部分。
    流和重定向
    生物信息学数据一般是文本，例如测序文件中的ATGC,参考基因组，制表符分割的基因坐标文件。文本文件通常非
常大，这就是Unix处理文本流的哲学的原因在生物信息学中很有用：文本流允许我们处理流数据而不是把它读取到内存
中。
    例如，假设我们有两个装满核苷酸序列的文件，以FASTA的格式储存，一种标准的文本格式，用于存储序列数据（通常
是DNA，但偶尔也有）蛋白质也是）。即使是将这两个大文件合并到一个文件中的简单任务也会变得很棘手，尽管这些文件的
大小只有几GB。如果不使用unixshell，如何完成这个简单的任务？您可以尝试打开一个文件，选择并复制其所有内容，
然后将其粘贴到另一个文件中。但是，这不仅需要在内存中加载两个文件，而且在选择“全部”、“复制”和“粘贴”时，还需要
使用额外的内存来复制一个文件。像这样的方法不适合我们在生物信息学中经常使用的数据量。此外，将内容粘贴到文件中并
没有遵循第1章：将数据视为只读的建议。如果出了问题，其中一个文件（或两个文件都有！）很容易被破坏。更糟糕的是，
复制和粘贴大文件会占用大量内存，因此您的计算机很可能出现问题。Streams为这些问题提供了一个可伸缩的、健壮的解决方案。
    重定向到标准输出
    简单的合并两个文件可以采用流。使用流可以让我们减少内存的使用。相反，我们合并大文件通过把他们打印到标准输出，
然后重定向流到一个文件。你可能是用cat打印文件的内容到标准输出（当没有重定向时，它会被打印到终端屏幕上）。例如，
我们可以看看tb1-蛋白质.fasta文件（可在GitHub上本章的目录中找到）使用cat将其打印到标准输出：
```bash
$ cat tb1-protein.fasta
>teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
```
    cat还允许我们将多个文件的内容按命令参数出现的顺序打印到标准输出流中。这基本上连接了这些文件，如下所示的tb1和
tga1翻译序列：
```bash 
$ cat tb1-protein.fasta tga1-protein.fasta
>teosinte-branched-1 protein
LGVPSVKHMFPFCDSSSPMDLPLYQQLQLSPSSPKTDQSSSFYCYPCSPP
FAAADASFPLSYQIGSAAAADATPPQAVINSPDLPVQALMDHAPAPATEL
GACASGAEGSGASLDRAAAAARKDRHSKICTAGGMRDRRMRLSLDVARKF
FALQDMLGFDKASKTVQWLLNTSKSAIQEIMADDASSECVEDGSSSLSVD
GKHNPAEQLGGGGDQKPKGNCRGEGKKPAKASKAAATPKPPRKSANNAHQ
VPDKETRAKARERARERTKEKHRMRWVKLASAIDVEAAAASVPSDRPSSN
NLSHHSSLSMNMPCAAA
>teosinte-glume-architecture-1 protein
DSDCALSLLSAPANSSGIDVSRMVRPTEHVPMAQQPVVPGLQFGSASWFP
RPQASTGGSFVPSCPAAVEGEQQLNAVLGPNDSEVSMNYGGMFHVGGGSG
GGEGSSDGGT
```
    虽然这些文件已连接，但结果不会保存在这些文件的任何位置线只是打印到终端屏幕上。为了保存这些串联的
结果到一个文件，你需要从你的终端重定向这个标准输出流屏蔽到文件。重定向是Unix中的一个重要概念，也是生
物信息学中经常使用的概念。
    重定向到“标准”或“我们”操作符>输出。接线员>将标准输出重定向到文件并覆盖该文件的任何现有内容（请注
意这一点并小心），而后面的运算符>>会附加到文件中（保留内容，并添加到末尾）。如果没有现有文件，则操作员
将在将输出重定向到它之前创建它。把我们的两个FASTA连在一起文件，我们像以前一样使用cat，但将输出重定向
到一个文件：
    $ cat tb1-protein.fasta tga1-protein.fasta > zea-proteins.fasta
    请注意，当您将标准输出重定向到文件时，您的终端屏幕上不会打印任何内容。在我们的示例中，整个标准输
出流以zea-proteins.fasta文件。将标准输出流重定向到文件如下所示:
    我们可以通过检查这个目录中最近创建的文件是否是我们刚刚创建的文件（即zea）来验证我们的重定向是否
正常工作-蛋白质.fasta):
```bash
ls -lrt
total 24
-rw-r--r-- 1 vinceb staff 353 Jan 20 21:24 tb1-protein.fasta
-rw-r--r-- 1 vinceb staff 152 Jan 20 21:24 tga1-protein.fasta
-rw-r--r-- 1 vinceb staff 505 Jan 20 21:35 zea-proteins.fasta
```
    将-lrt添加到ls列出此目录中以列表格式（-l）的文件，倒序（-r）时间排序（-t）（有关详细信息，请参
阅man ls）。另外，请注意这些标志组合成-lrt；这是一个常见的语法快捷方式。如果你想看最新的文件在顶部，
您可以省略r标志。
    重定向标准错误
    由于许多程序使用标准输出流来输出数据，因此流对于用户要读取的错误、警告和消息是必需的。标准错误是
一个仅用于此目的的流（如图3-1所示）。像标准的输出，默认情况下，标准错误被定向到您的终端。在实践中，我
们经常希望将标准错误流重定向到文件以便消息、错误和警告记录到一个文件中，我们可以稍后检查。

    为了说明如何重定向标准输出和标准错误，我们将使用ls-l命令列出现存在的文件（tb1.fasta）和不存在的文件
（leafy1.fasta）。现有文件tb1.fasta的ls-l输出将被发送到标准输出，同时会出现一条错误消息leafy1.fasta
不存在。现有文件tb1.fasta的ls-l输出将被发送到标准输出，而错误消息leafy1.fasta不存在将输出到标准错误。
当您不重定向任何内容时，两个流都会输出到您的终端：
```bash 
$ ls -l tb1.fasta leafy1.fasta
ls: leafy1.fasta: No such file or directory
-rw-r--r-- 1 vinceb staff 0 Feb 21 21:58 tb1.fasta
```
    为了将每个流重定向到单独的文件，我们将上一节中的>运算符与用于重定向标准错误流的新运算符2>结合在一起：

```bash 
$ ls -l tb1.fasta leafy1.fasta > listing.txt 2> listing.stderr
$ cat listing.txt
-rw-r--r-- 1 vinceb staff 152 Jan 20 21:24 tb1.fasta
$ cat listing.stderr
ls: leafy1.fasta: No such file or directory
```
    另外，2>有2>>，类似于>>（它将附加到文件而不是覆盖它）。
    文件描述器
    2>看起来很神秘，很难记住，但是标准错误的重定向操作符中有一个2是有原因的。Unix系统上所有打开的文件（包括流）都是
分配了一个称为文件描述符的唯一整数。Unix的三个标准流标准输入（稍后我们将看到）、标准输出和标准错误分别被赋予文件描述
符0、1和2。甚至可以使用1>作为标准输出的重定向操作符，尽管这在实践中并不常见，并且可能会使协作者感到困惑。
    有时程序会产生我们不需要或不关心的消息。重定向可以是使某些程序写入的诊断信息静音的有用方法,标准输出：我们只是重定
向到一个日志文件stderr.txt文件. 但是，在某些情况下，我们不需要将此输出保存到文件中，并且将输出写入物理磁盘可能会减慢
速度程序关闭。幸运的是，类Unix的操作系统有一个特殊的“假”磁盘（称为伪设备）将不需要的输出重定向到：/dev/null。输出已
写入to/dev/null消失了，这就是为什么它有时被戏称为“黑洞”.
    使用tail-f监视重定向标准错误
    我们经常需要重定向标准输出和标准错误，对于大型生物信息学程序可能运行数天（或可能几个星期，或者几个月！）。当这两个
流都改变方向时，不会向终端打印任何内容，包括有用的诊断，您可能需要在长时间运行期间关注的消息任务。如果您希望跟踪这些消息，
程序尾部可以用于通过调用tail查看输出文件的最后一行文件名.txt. 例如，跑尾巴stderr.txt文件将打印文件的最后10行stderr.txt
文件. 你可以设定确切的数字行尾将使用-n选项打印。
    Tail还可以用于持续监视带有-f（-f for）的文件跟随）。当被监视的文件被更新时，tail将显示新的线到终端屏幕，而不是只显示
10行和没有这个选项就会退出。如果你想阻止监控一个文件，可以用Control-C中断尾部过程。写入文件的过程不会中断当你闭上尾巴。

    使用标准输出重定向
    UNIX壳牌还提供标准输入的重定向算子。正常地

标准输入从键盘输入，但在<重定向操作员

可从文件中直接读取标准输入。尽管标准输入重定向是有限的

尽管标准输入重定向不如>、>>和2>常见，但它偶尔还是有用的：
```bash 
$ program < inputfile > outputfile
```
    在这个例子中，这个input文件通过标准输入传入程序，程序的标准输出重定向到一个输出文件。
    与使用<相比，使用Unix管道是比较常用的（例如 cat inputfile | program > output）。我们后面看到的很多程序
，像awk,grep,sort）除了使用标准输入，还可以传入参数。其他程序，（在生物信息很普遍），使用单个-符号表示他们能使用
标准输入。但这是一种约定，而不是Unix的特性。
    万能的Unix管道：速度和美丽于一体
    当有必要以另一种方式处理数据时，我们应该有一些方法来连接程序，比如花园软管螺钉。在“为什么我们在生物信息学中使用
Unix？”？模块化与Unix哲学在第37页，麦克罗伊的引文包括了推荐信，编写程序一起工作。多亏了Unix管道，这个概念是McIlroy
自己发明的。Unix管道与我们前面看到的重定向操作符类似，只是管道没有将程序的标准输出流重定向到文件，而是将其重定向到另一
个文件程序的标准输入。只有标准输出通过管道传输到下一个命令；标准错误仍然打印到终端屏幕上，如图3-2所示。
    您可能会想知道为什么我们要将程序的标准输出直接传送到另一个程序的标准输入，而不是将输出写入文件然后读取这个文件进入
下一个程序。在许多情况下，创建文件将有助于检查工作流程的中间结果和可能的调试步骤为什么不每次都这样做呢？
    答案是，它通常归结为计算效率阅读和写入磁盘的速度非常慢。我们在生物信息学中使用管道（相当强制性）
不仅因为它们是建造管道的有用方法，而且因为它们更快（在某些情况下，要快得多）。现代圆盘的速度比记忆。例如，读取1兆字节的
从内存中读取数据，但从磁盘读取1兆字节只需2毫秒。这2毫秒是2000微秒，使得从磁盘读取的次数慢100倍（这是一个估计值；
实际数字将根据您的磁盘类型和速度）。
    在实际中，从磁盘中读取数据是数据分析的一个瓶颈。对于大量的二代测序数据，这是相当的慢。如果你完成了一个算法，使得
新版本的速度比老版本快2倍，你可能不会注意到读写到磁盘的差异。没有必要的输出会占用磁盘空间。对于大的二代测序数据和潜在的
实验数据，这会是一个问题。将一个程序的输出直接传递到另一个程序的输入中

    管道是连接Unix程序的一种计算效率高且简单的方法。这个是生物信息学家（和软件工程师）喜欢Unix系统。管道允许我们用更小
的模块化部件来制造更大、更复杂的工具。程序用什么语言编写也不重要，管道可以工作只要两个程序都能理解。作为大多数程序之间的
最小公分母，纯文本流经常被使用—McIlroy在他关于Unix哲学的引用中指出了这一点。
    Pipes-in-Action:使用Grep和Pipes创建简单程序
    生物信息学的黄金法则就是不要相信你的数据和工具。这种怀疑主义要求对中间结果进行持续的健全性检查，以确保您的方法不会偏
向数据，或者您的方法不会加剧数据中的问题。但是，编写自定义脚本来检查中间层的每一个位数据可能是昂贵的，即使你是一个可以编写
无缺陷代码的快速程序员。Unix管道允许我们快速迭代地构建微小的命令行程序来检查和操作数据，我们将在第7章中更深入地探讨这种方法
管道在更大的生物信息学工作流程中也被广泛使用（第12章），因为它们避免了将不必要的文件写入磁盘的延迟问题。
    我们将在本节学习管道的基础知识，为您在本书的其余部分中使用它们做好准备。让我们看看如何用管道将进程链在一起。假设我们正在
处理一个FASTA文件，程序警告它包含非核苷酸字符序列。你对此感到惊讶，因为序列只是DNA。我们可以使用管道和grep用Unix一行程序轻
松地检查非核苷酸字符。grep Unix工具在文件或标准输入中搜索匹配模式的字符串。这些模式可以是简单的字符串，也可以是正则表达式
（实际上有两种类型的正则表达式，basic和extended；有关更多详细信息，请参阅mangrep）。如果您不熟悉正则表达式，请参阅本书的
GitHub存储库的自述文件以获取资源。
    我们的管道将首先从FASTA文件中删除所有的头行（那些以>开头的），因为我们只关心序列是否具有非核苷酸字符。FASTA文件的其余
序列可以通过管道传输到grep的另一个实例，后者只打印包含非核苷酸字符的行。为了使这些字符更容易在我们的终端中被发现，我们还可以
给这些匹配的字符涂上颜色。整个命令如下所示：
```bash 
$ grep -v "^>" tb1.fasta | \
grep --color -i "[^ATCG]"
CCCCAAAGACGGACCAATCCAGCAGCTTCTACTGCTAYCCATGCTCCCCTCCCTTCGCCGCCGCCGACGC
```
    首先，我们删除以>字符开头的FASTA标题行。我们的正则表达式模式是^>，它匹配以>字符开头的所有行。
插入符号在正则表达式中有两种含义，但在本文中，它用于将模式锚定到行首.因为我们想排除以>开头的行，我们使用grep选项-v反转匹配的行。
最后，我们使用管道字符（|）将标准输出管道传输到下一个命令。反斜杠（\）字符只表示我们继续执行命令在下一行中，和用于提高可读性。
    第二，我们想找到不是A、T、C或G的任何字符。最简单的方法是构造一个与A、T、C或G不匹配的正则表达式模式。为此，我们在正则表达式
中使用插入符号的第二个含义。当在括号中使用时，插入符号将匹配不是这些括号中的字符之一的任何字符。因此，模式[^ATCG]匹配任何非A、T、
C或G的字符。此外，我们忽略带-i的大小写，因为A、T、C和G是有效的核苷酸（小写字符通常用于表示隐藏的重复序列或低复杂度序列）。
最后，我们添加grep的--color选项来为匹配的非核苷酸字符着色。
    在终端窗口中运行时，将突出显示“Y”。有趣的是，Y实际上是根据IUPAC制定的标准有效的扩展二义核苷酸编码。
Y代表嘧啶碱：C和T。其他单字母IUPAC代码可以表示序列数据中的不确定性。例如，嘌呤碱基用R表示，而a、G或T的碱基的代码是D。
让我们讨论一下关于这个简单的Unix管道的一些附加要点。首先，注意这两个正则表达式都是引号，这是一个很好的习惯。相反，如果
我们如果使用grep-v>tb1.fasta，shell会将>解释为重定向运算符而不是提供给grep的模式。不幸的是，这会错误地覆盖tb1.fasta文件！
大多数生物信息学家在某些地方犯了这个错误指出这一点并从中吸取了教训（通过丢失他们希望恢复的FASTA文件），所以要小心。
    这个简单的Unix一行程序只需要几秒钟的时间来编写和运行，对于这个特定的任务非常有用。我们可以编写一个更复杂的程序显式
解析FASTA格式，计算出现的次数，并输出一个包含非核苷酸字符的序列名列表。但是，为了我们的任务为什么一个程序不能在运行中构建
简单的命令行工具是快速而充分的。我们将看到更多关于如何构建命令行工具的示例在第7章中使用Unix数据程序和管道。
    把管道和重定向结合起来
    大的生信软件像比对软件，组装软件，和SNPcall软件，会同时使用多个文本流。结果输出到标准输出，诊断信息，警告，报错会被输出
到标准错误输出。在这种情况下，我们需要将管道和信息流结合起来。
    例如，假设我们有两个虚构的程序：program1和program2。我们的第一个程序program1处理输入文件，并将结果输出到标准输出流，
并将诊断消息输出到标准错误流。第二个程序，program2，把program1的标准输出作为自己的输入。program2也把自己的诊断信息输出到
标准错误输出，结果输出到标准输出。棘手的部分是我们现在有两个进程同时输出到标准错误和标准输出。如果我们没有同时捕获program1和
program2的标准错误流，我们的屏幕上就会出现一堆混乱的诊断信息，滚动速度太快，我们无法阅读。幸运的是，我们可以轻松地组合管道和
重定向：
```bash 
$ program1 input.txt 2> program1.stderr | \
program2 2> program2.stderr > results.txt
```
    程序1处理输入.txt输入文件，然后将其结果输出到标准输出。program1的标准错误流被重定向到program1。stderr日志文件。与以前
一样，反斜杠用于拆分这些命令跨越多行以提高可读性（在您自己的工作中是可选的）。
    同时，program2使用program1的标准输出作为其标准输入。shell将program2的标准错误流重定向到program2.stderr
logfile和program2的标准输出结果.txt.
有时，我们需要将标准错误流重定向到标准输出。

    例如，假设我们想使用grep在program1的标准输出和标准错误流中搜索“error”。使用管道是行不通的，因为管道只将一个程序的标准输
出链接到下一个程序的标准输入。管道忽略标准错误。我们可以通过首先将标准错误重定向到标准输出，然后将合并后的流管道传输到grep来解决
这个问题：
```bash 
$ program1 2>&1 | grep "error"
```
    2>&1运算符将标准错误重定向到标准输出流。
    使用tee再接一次重定向
    如前所述，管道可以防止不必要的磁盘写入和读取操作通过将一个进程的标准输出连接到另一个进程的标准输入。但是，我们有时确实需要在
Unix管道中将中间文件写入磁盘。当调试管道或希望为需要较长时间完成的步骤存储中间文件时，这些中间文件非常有用.
像一个管道工的T形接头，Unix程序T形接头会转移管道标准的副本将流输出到中间文件，同时仍将其传递到标准输出：
```bash 
$ program1 input.txt | tee intermediate-file.txt | program2 > results.txt
```
在这里，program1的标准输出都写入了intermediate-file.txt并直接传输到program2的标准输入。

    进程查看和管理
    当我们通过unixshell运行程序时，它们将成为进程，直到它们成功完成或因错误而终止。你的机器同时运行多个进程，
例如，系统进程，以及你的网络浏览器、电子邮件应用程序、生物信息学程序等。在生物信息学中，我们经常处理运行时间很
长的进程，所以我们了解如何从unixshell使用和管理进程。在本节中，我们将学习操作流程的基本知识：在后台运行和管理
流程、终止错误的流程以及检查流程退出状态。
    后台进程
    当我们在shell中键入一个命令并按Enter键时，无论命令运行多长时间，我们都无法访问shell提示符。对于短期任务
来说，这是可以的，但是等待一个长时间运行的生物信息学程序完成后再继续在shell中工作，这将扼杀我们的生产力。而不是
在前台运行程序（与通常运行命令时一样），shell还提供了在后台运行程序的选项。在后台运行进程释放提示，以便您可以继
续工作。
我们可以告诉unixshell在后台运行一个程序，方法是在命令的末尾附加一个和号（&）。例如：
```bash
$ program1 input.txt > results.txt &
[1] 26577
```
shell返回的数字是program1的进程ID或PID。这是一个唯一的ID，允许您稍后识别和检查program1的状态。我们可以通过
作业检查后台运行的进程：
```bash 
$ jobs
[1]+ Running program1 input.txt > results.txt
```

为了再次将背景处理带入前景，我们可以使用fg（前台）。fg将为前景带来最新的流程。如果您有许多进
程在后台运行，它们都将显示在程序作业的列表输出中。类似[1]的数字是作业ID（与系统分配正在运行的程序的进程ID不同）。
返回特定背景作业到前台，使用fg%<num>其中<num>是作业列表中的编号。如果我们要将程序1返回前景，fg和fg%1都会执行
相同的操作事情，因为只有一个背景过程：
```bash 
$ fg
program1 input.txt > results.txt
```
    背景处理和挂断信号
    有一个关于后台进程的小问题：尽管它们在后台跑，好像和我们的终端断开了，关闭终端窗口会导致这些进程被终止。不幸的是，
许多长期运行的重要工作不小心被杀了。
    每当我们的终端窗口关闭时，它就会发出一个挂断信号。挂断信号（也称为SIGHUP）来自网
络连接不太可靠的时代。断开的连接可能会阻止用户停止异常、资源匮乏的情况过程。为了解决这个问题，挂断信号被发送到所有进程
从封闭终端启动。几乎所有Unix命令行程序一收到这个信号就停止运行。因此请当心-在后台运行进程并不能保证它不会在您的终端关
闭时消失。为了防止这种情况，我们需要使用工具nohup或在Tmux中运行它，两个主题我们将在第4章中更详细地介绍。
    也可以将已经在前台运行的进程置于后台。为此，我们首先需要暂停该过程，然后使用bg命令在后台运行它。暂停进程会暂时将
其暂停，允许您将其放在后台。我们可以通过发送停止来暂停流程通过组合键Control-z发出信号，通过我们的假想程序1，我们将
完成此操作，如下所示：
```bash 
$ program1 input.txt > results.txt # forgot to append ampersand
$ # enter control-z
[1]+ Stopped program1 input.txt > results.txt
$ bg
[1]+ program1 input.txt > results.txt
```

与之前的fg一样，我们也可以使用作业来查看暂停的进程的作业ID。要是我们有多个正在运行的进程，我们可以指定将哪个移至后台使用bg％<num>（其中<num>是作业ID）。

杀掉进程
有时我们需要终止进程。有些程序会需要过多的计算资源或者无法响应，，这就要求我必须要杀掉进程。杀死一个进程永远可以结束它，这与
使用停止信号将其挂起，杀掉是无法恢复的。如果该进程当前正在运行在shell中，您可以通过输入Control-C将其杀死.这仅仅对在前端
运行的进程有用，如果在后端运行的程序，你必须使用之前的fg命令。
更多高级的进程管理，（包括top/ps监控，查找进程，或者使用kill 杀掉进程）超出了这章内容。然而，在Github上的README中有很多
关于进程和资源的信息。

退出状态
长时间运行的进程，你可能不会一致监控直到它运行完成。怎样直到它是否完成呢。你怎么知道他是否完成还是报错呢？Unix程序退出会有
一个退出状态，它表示程序退出是否正常还是有错误。按照Unix的标准，退出状态是0表示进程运行成功，其他非0的数表示运行存在问题。

警告退出状态
不幸的是，程序在返回时是否返回非零状态遇到错误取决于程序开发人员。偶尔，程序员忘了很好地处理错误（确实如此）发生在生物信息
学程序中），程序可能会出错仍然返回零退出状态。这是另一个原因遵循黄金法则至关重要（即，不要相信您的工具），并且始终检查您的
中间数据。

退出状态不会显示在终端上，但是shell会将其值设置为一个变量在名为$？中（适当地命名为shell变量）。
在运行完一个程序后，我们可以打印出这个变量的值：
```bash
$ program1 input.txt > results.txt
$ echo $?
0
```
退出状态是非常有用的，他能让我们在shell中程序化的将命令联系到一起。下一个命令的运行，取决于上一个命令的状态。shell中有两个
操作符号来实现这一个功能。一个是&&，只有第一个命令运行成功才会运行下一个命令。另外一个是||，只有第一个命令运行失败才会运行
下一个命令。如果您熟悉短路的概念评估，您将了解这些运算符正在短路，分别表示和，或者。
最好在示例中查看这些运算符。假设我们要运行program1，将其输出写入文件，然后让program2读取此输出。为了避免由于program1
终止，program2读取的文件不完整的问题出现错误，我们只想在program1返回零（成功）之后启动program2退出代码。 Shell运算符
&&仅在前一个命令执行后继命令命令已完成，并且退出状态为非零：
```bash 
$ program1 input.txt > intermediate-results.txt && \
program2 intermediate-results.txt > results.txt
```

使用||运算符，仅当上一个命令失败（以非零状态退出）。这对于警告消息很有用.
```bash 
$ program1 input.txt > intermediate-results.txt || \
echo "warning: an error occurred"
```
如果要测试&&和||，有两个Unix命令除了什么都不做返回退出成功（true）或退出失败（false）。例如，考虑一下为什么
打印以下行：
```bash 
$ true
$ echo $?
0
$ false
$ echo $?
1
$ true && echo "first command was a success"
first command was a success
$ true || echo "first command was not a success"
$ false || echo "first command was not a success"
first command was not a success
$ false && echo "first command was a success"
```

此外，如果您不在乎退出状态，而只想执行两个
依次使用命令，则可以使用单个分号（;）：
```bash 
$ false; true; false; echo "none of the previous mattered"
none of the previous mattered
```
如果您只知道外壳是通过终端与之交互的东西，您可能会开始注意到它具有完整编程语言的许多元素。这是因为！实际上，您可以像编
写和执行shell脚本一样做Python脚本。让你的生物信息学Shell脚本运行在注释中保证shell版本的一致性，是确保你的工作可重复
的最佳方法。我们将在第12章中讨论Shell脚本。

替换命令
Unix用户喜欢让Unix Shell为他们工作-这就是为什么Shell扩展像通配符和括号扩展一样存在。另外一个有用的拓展就是shell的替换。
命令替换将内联运行Unix命令，并以字符串形式返回输出，该字符串可以在另一个命令中使用。这开辟了许多有用的可能性。

一个很好的例子是在新年的早期，当我们尚未调整为使用新日期。例如，在2013年的五天内，我分享了
与我的合作者一起的新结果目录名为snp-sim-01-05-2012（以mmdd-yyyy格式）。尴尬消退后，提出
了Unix解决方案本身：date命令用于以编程方式返回当前日期串。我们可以使用此字符串来自动给我们的目录名称包含
当前日期。我们使用命令替换来运行日期程序并替换此命令及其输出（字符串）。通过以下方式更容易理解比较简单的例子：
```bash 
$ grep -c '^>' input.fasta
416
$ echo "There are $(grep -c '^>' input.fasta) entries in my FASTA file."
There are 416 entries in my FASTA file.
```

此命令使用grep进行计数（-c选项代表count）
匹配模式的线。在这种情况下，我们的模式^>与FASTA标头匹配
线。因为每个FASTA文件条目都有一个开头为“> sequence-a”的标头
如果使用“>”，则此命令将与每个标头匹配并计算
FASTA条目。


现在假设我们要获取grep命令的输出并将其插入
到另一个命令中—这就是命令替换的全部内容。在这个
在这种情况下，我们希望echo打印一条消息，其中包含多少个FASTA条目
是标准输出。使用命令替换，我们可以计算并返回
直接输入此字符串的FASTA条目数！

使用此命令替换方法，我们可以轻松创建带日期的目录
使用命令date +％F，其中参数+％F只是告诉日期程序
以特定格式输出日期。日期具有多种格式选项，因此
您的欧洲同事可以将日期指定为“ 2011年5月19日”，而您的美国同事
同事可以指定“ 2011年5月19日：”

```bash 
$ mkdir results-$(date +%F)
$ ls results-2015-04-13
```

通常，对于带日期的目录，由date +％F返回的格式是一种非常好的格式，
因为当结果按名称排序时，这种格式的目录也会按时间顺序排序：
```bash 
$ ls -l
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 1999-07-01
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2000-12-19
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2011-02-03
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2012-02-13
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 2012-05-26
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:22 2012-05-27
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 2012-07-04
drwxr-xr-x 2 vinceb staff 68 Feb 3 23:23 2012-07-05
```
这背后的巧妙之处在于使这种称为ISO 8601的日期格式有用。


保存你的Unix技巧
在第2章中，我们使用mkdir -p和brace创建了一个项目目录扩展。如果你发现你经常创建相同的目录结构，
把它储存起来，而不是每次都打印一次。为什么要重复呢？
早期的Unix用户非常聪明（或懒惰），他们设计了一种工具用于存储重复的命令组合：别名。
如果您正在跑一遍又一遍的聪明单行，使用添加别名添加它到您的〜/ .bashrc（或OS X上的〜/ .profile）。
只是你的命令以较短的名称别名。例如，如果您总是创建具有相同目录结构的项目目录，添加一个像下面这样的行：
```bash 
alias mkpr="mkdir -p {data/seqs,scripts,analysis}"
```
对于像这样的小东西，编写更复杂的东西是没有意义的剧本;采用Unix方式并保持简单。另一个例子是我们可以将date +％F命令别名为今天：
```bash 
alias today="date +%F"
```

现在，输入mkdir results-$（today）将创建一个带日期的结果目录。
不过请注意，不要别名项目层级的shell脚本，这些简写会在你的shell重启时，当你在其他项目目录下。
如果分发项目，所有需要别名定义的shell程序都会不起作用。在计算中，我们说这样的做法不是可移植
的-如果它离开您的系统，它将不起作用。编写可移植的代码，即使它不会运行在其他地方，将有助于保持项目的可重复性。

像所有好的东西一样，Unix技巧（例如命令替换）最好用于节制。一旦您对这些技巧有所了解，它们将变得非常快捷，容易
解决常规烦恼的方法。一般来说，最好保持简单并知道何时可以使用快速的Unix解决方案以及何时使用其他工具
像Python或R。我们将在第7章和第8章中对此进行更深入的讨论。


